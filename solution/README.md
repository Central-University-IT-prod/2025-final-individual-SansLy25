## Зависимости и основания для выбора

### 1. **Python**
Python - это высокоуровневый язык программирования, который широко используется для разработки веб-приложений, анализа данных, ML и многих других областей.
- Универсальность и простота, Python является одним из самых популярных языков программирования благодаря своей простоте синтаксиса, это позволяет быстро разрабатывать и поддерживать код.
- Высокоуровневость, динамическая типизация и автоматическое управление паматью идеальны для web разработки, ведь здесь важно сосредотачивается на бизнес-логике, а не на технических деталях и CPU производительности, здесь гораздо важнее работа с IO bound с которым Python справляется неплохо благодаря поддержке асинхронности и современным ORM.
- Широкая экосистема, Python имеет огромное количество библиотек и фреймворков, которые упрощают разработку сложных приложений.
- Стандартная библиотека, швейцарский нож в мире стандартных библиотек, в ней есть все от работы с ОС и сетью до создания GUI приложений.
- Производительность, да как бы это смешно не было, но Python вполне может быть производительным языком, это возможно благодаря поддержке расширений на c++, которые в использовании ничем не отличаются от обычных библиотек, поэтому если где то нужна очень большая CPU производительность то это вполне возможно (тот же ML это почти всегда Python с расширениями на C++).
- Поддержка сообщества, Python активно развивается большим сообществом разработчиков.

### 2. **Django**
Django — это высокоуровневый Python-фреймворк, который предоставляет множество встроенных инструментов для быстрой разработки веб-приложений.
- **Причины выбора:**
  - Наличие огромного количества встроенных инструментов, таких как аутентификация, маршрутизация, тестирование, админ-панель, работа с часовыми поясами, медиа, статикой, middleware и многое другое, это действительно фреймворк, а не микрофреймворк как тот же FastAPI или Flask
  - Встроенная ORM которая идеально интегрируется с фреймворком, Django ORM предоставляет более высокоуровневый и удобный интерфейс нежели тот же SQLAlchemy, но при этом позволяет и работать на более низком уровне если нужна высокая производительность.
  - Гибкость, несмотря на огромное количество встроенных элементов они тебя не сковывают, ты всегда можешь поменять их под себя, не создавая их с нуля
  - DRY (Don't Repeat Yourself) - в основе Django лежит принцип DRY, что позволяет избежать дублирования кода и упрощает его поддержку и развитие, а также экономит время разработчика, что очень важно в наше время.
  - Тестирование в Django гораздо проще, чем в других фреймворках, встроенные инструменты позволяют совершать запросы к приложению, создавать временные БД, а все тесты Django сам находит и позволяет запустить тестирование всего одной командой.
  - Маршрутизация, Django предоставляет мощный механизм для маршрутизации запросов, можно указывать параметры в URL, создавать группы маршрутов, использовать регулярные выражения, подключать другие url через префиксы и многое другое.


### 3. **Django REST Framework (DRF)**
DRF — это мощный и гибкий инструмент для создания RESTful API на основе Django.
- **Причины выбора:**
  - CBV (Class Based Views) - Классовые представления позволяют создавать эндпоинты гораздо быстрее и удобнее, используя все приемущества ООП, такие как наследование и переопределение методов, за счет этого можно избежать огромного количества одинакового кода, другие популярные Python REST фреймворки не позволяют создавать представления на основе классов.
  - Автоматизация CRUD, DRF предоставляет различные готовые CBV для создания CRUD эндпоинтов, что позволяет создавать их гораздо быстрее, это возможно опять же благодаря встроенной ORM и ООП. Лишь немного видоизменив готовые представления с помощью переопределения методов можно управлять поведением очень гибко, не делая boiler plate кода.
  - DRF поддерживает такие форматы данных, как JSON и XML, что делает его универсальным для взаимодействия с различными клиентами.
  - Интеграция с Django ORM позволяет легко работать с моделями базы данных, можно создавать сериализаторы на основе моделей, буквально в пару строк.
  - Объемная сериализация (тоже на основе ООП), DRF поддерживает сериализацию и валидацию большого типов данных, даже файлов, для полей можно определять множество параметров валидации который сериализатор автоматически проверит.

### 4. **LLM Gigachat**
Gigachat — это мощная отечественная языковая модель, которая использована модерации и генерации текстов в рамках API.
- **Причины выбора:**
  - Отечественная разработка, модель гораздо лучше понимает наш великий и могучий (и наш мат тоже, что важно для модерации) чем зарубежные аналоги, также сервера расположены ближе что обеспечивает скорость соединения, ну и доступ к LLM не будет утрачен из-за санкций или блокировок.
  - Производительность, среди всех отечественных моделей она показывает лучшую производительность в задачах анализа текста.
  - Дешевизна, в сравнении с зарубежными аналогами, LLM Gigachat предоставляет доступ к своему API по более низкой цене, а для физических лиц вообще бесплатно 100тыс токенов в год.

### 5. **Nginx**
Nginx — это высокопроизводительный веб-сервер и обратный прокси-сервер.
- **Причины выбора:**
  - Одна из лучших производительностей среди веб-серверов, Nginx способен обрабатывать большое количество одновременных соединений и запросов.
  - Он используется для обработки HTTP-запросов, балансировки нагрузки и кэширования, что повышает производительность и отказоустойчивость приложения.
  - Легкая и гибкая настройка

### 6. **Gunicorn**
- **Причины выбора:**
  - Gunicorn — это WSGI-сервер для запуска Python-приложений, таких как Django.
  - Он прост в настройке и обеспечивает высокую производительность при обработке запросов.
  - Gunicorn работает в связке с Nginx, где Nginx выступает в роли обратного прокси, а Gunicorn — в роли сервера приложений.

### 7. **PostgreSQL**
PostgreSQL — это мощная, надежная и масштабируемая база данных с открытым исходным кодом.
- **Причины выбора:**
  - Самая производительная SQL база данных на данный момент.
  - Надежность и масштабируемость, PostgreSQL обеспечивает высокую отказоустойчивость и масштабируемость приложения.
  - Поддержка дополнительных типов данных например массивов или JSON, что бывает очень удобно
  - Django имеет встроенную поддержку PostgreSQL, что упрощает интеграцию и работу с базой данных.


### Итог
Выбор данных технологий обусловлен их надежностью, производительностью и удобством интеграции. Django и DRF предоставляют мощную основу для создания REST API, Gigachat добавляет интеллектуальные возможности, а Nginx, Gunicorn и PostgreSQL обеспечивают стабильную и масштабируемую работу приложения в production-среде.

---
## Инструкция по запуску

Приложение можно запустить в двух режимах: **production** и **dev**. 

- **Production** — стандартный запуск через `docker-compose`.
- **Dev** — режим для отладки и локального запуска при разработке.

### Конфигурация

Для запуска приложения необходимо настроить переменные окружения.
Некоторые переменные (например, параметры БД) уже определены в `docker-compose`,
поэтому при запуске через Docker их указывать не нужно. Однако при запуске в **dev** режиме эти переменные обязательны.

- Конфигурация для **production** находится в файле `.env` в директории `solution/`.
- Конфигурация для **dev** режима находится в файле `.env` в директории `solution/api/src`.

Для изменения конфигурации просто отредактируйте соответствующий файл `.env`.

#### Описание переменных окружения

- `POSTGRES_DB` — Имя базы данных (только для **dev** режима).
- `POSTGRES_USER` — Имя пользователя базы данных (только для **dev** режима).
- `POSTGRES_HOST` — Хост базы данных (только для **dev** режима).
- `GIGACHAT_TOKEN` — Токен для LLM Gigachat (подробнее в разделе про интеграцию с LLM).
- `GIGACHAT_SCOPE` — Версия API Gigachat (подробнее в разделе про интеграцию с LLM).
- `MODERATE_AD_TEXT` — Включает постоянную модерацию текста рекламы (`true` или `false`).
- `DJANGO_DEBUG` — Режим отладки Django (`true` или `false`).
- `MULTI_PART_DATA_CAMPAIGN' - Включает возможность загрузки изображений для рекламы (`true` или `false`, подробнее в разделе про загрузку изображений).

### Запуск через docker-compose

1. Установите Docker и `docker-compose`.
2. Перейдите в директорию solution
3. Измените конфигурацию .env файле при необходимости
4. Соберите образы:
   ```bash
   docker-compose build
5. Запустите контейнеры:
   ```bash
   docker-compose up -d

`docker-compose` создаст три контейнера: **API**, **PostgreSQL** и **Nginx**. **API** будет доступен по адресу: http://localhost:8080.

### Запуск в dev режиме
1. Создайте базу данных в **PostgreSQL** на порту `5432` и пропишите её параметры в `.env` файл.
2. Установите Python версии 3.12
3. Перейдите в директорию `solution/api/`
4. Установите зависимости:
   ```bash
   pip install -r requirements.txt
5. Перейдите в директорию `src/`
6. Запустите тестовый сервер:
   ```bash
   pip install -r requirements.txt

Сервер будет доступен по адресу: http://localhost:8000.

---

## Описание эндпоинтов
Мне кажется не очень целесообразным здесь повторять спецификацию, поэтому тут **я опишу только то чего в ней нет**: дополнительные параметры и логику, а также ответы и ошибки и логику работы
### Создание и управление промокодам
Для создания и обновления промокода добавляется 2 **необязательных** параметра:
- `description_prompt: string` - описание промокода для генерации текста, **не может быть** передано вместе с `ad_text`, подробнее в разделе про интеграцию с LLM
- `moderate_ad_text: bool` - флаг модерации, если передан то текст рекламы будет отправлен на модерацию, это способ промедировать текст без установки переменной окружения в True, подробнее в разделе про модерацию

В режиме MULTI_PART_DATA_CAMPAIGN: true, добавляется еще один **необязательный** параметр, но только при запросе в формате `form-data` и при этом значении переменной окружения, подробнее в разделе про загрузку изображений
- `uploaded_images: file` - изображение для промокода, подробнее в разделе про загрузку изображений
в ответе в этом режиме будет массив `images` с url изображений (тоже только MULTI_PART_DATA_CAMPAIGN: true )

#### Валидация:
Все числовые поля должны быть больше 0, `start_date` должен быть меньше `end_date`, age_from должен быть меньше `age_to`, `text_ad` и `description_promt` не могут быть оба в одном запросе, они взаимозаменяемы, при не прохождении валидации кидается код `400`

#### Логика при обновлении:
Если передано поле которое неизменяемо после старта кампании, и она началась то просто кидается 400, остальное работает так же как и при создании

#### Логика при несуществующих campaign и advertiser:
Если campaign или advertiser не существует, то будет возвращен код 404, если advertiser существует и campaign существует, но кампания не принадлежит этому рекламодателю то тоже будет кинут 404

### Bulk эндпоинты для клиентов и рекламодателей
Логика одинаковая, если клиент или рекламодатель с указанным id в списке не существует то мы его создаем, если существует то обновляем, если в списке есть несколько объектов с одинаковым id, то будет создан тот что был передан последним, и в ответ пойдет только он 

#### Валидация:
Для клиентов проверяется что `age_from` меньше `age_to` и что `gender` MALE или FEMALE, если валидация не проходит то кидается 400

### Показ рекламы, просмотры и клики

#### Логика показа и клика
При переходе по `/ads` среди всех реклам выбираются подходящие, если на текущий момент нет рекламы подходящей по таргетингу, тех у которых не превышен лимит и тех которые начались (start_date <= today <= end_data) то кидается 404,
если нашлись подходящие рекламы, то алгоритм ранжирует их и выбирает самую высокооцененную, после чего отдает его пользователю и создает объекта просмотра в БД (`AdImpression`), если пользователь рекламу видел, то объект не создастся и количество просмотров у рекламы увеличено не будет
при клике создается объект `AdClick`, с ним все так же работает, если пользователь не просмотрел рекламу и кликнул на рекламу, то вернется 403

#### Логика при несуществующих client_id и ad_id
Если клиента или рекламы (при клике) с указанным id не существует, то 404

### Ml score
Для одной пары клиент и рекламодатель хранится только один MLScore, если он уже есть то он обновляется, если нет то создается новый

#### Логика при несуществующих client_id и advertiser_id
Если клиента или рекламодателя с указанным id не существует, то 404

### Статистика
Логика интересная, тк рекламодатель может изменить цену за клик или просмотр, поэтому просто умножить цену на количество чтобы получить итоговую стоимость не выйдет, тк во время клика или просмотра цена могла быть другой, поэтому для каждого клика или просмотра фиксируется его цена, а также день в который он был совершен, после чего на основе этих данных можно вычислить стоимость по каждому дню.

Если нужно посчитать статистику для всего рекламодателя, то показатели суммируются для каждой рекламы

#### Логика при несуществующих advertiserId и campaignId
Если рекламы или рекламодателя с указанным id не существует, то 404

## Интеграция с LLM

### Подключение
Для генерации текста рекламы используется LLM Gigachat. Для работы с API GigaChat необходимо указать токен и версию API в переменных окружения:

- `GIGACHAT_TOKEN=REDACTED==`
- `GIGACHAT_SCOPE=GIGACHAT_API_PERS`

Также для работы с GigaChat нужен сертификат _Минцифры_, он создан и находится в папке `solution/api/certs`

### Генерация текстов
Чтобы текст рекламы был сгенерирован надо передать в теле запроса на создание или обновление параметр "description_prompt: string",
(важно, что он не может быть передан вместе с "ad_text", они взаимозаменяемы, если переданы оба то будет 400) этот параметр
это описание текста рекламы рекламодателем, не весь промпт а лишь описание,
например: "Зоомагазин у дома, доступные цены, много товаров и акций", в заготовленный 
промпт для GigaChat вставляется это описание, также в промпт передается название 
компании и рекламы, поэтому если нужно сгенерировать текст только на основе них, 
то можно передать просто пробел в `description_prompt`: **"description_prompt": " "**

## Модерация на основе LLM
Модерацию осуществляет Gigachat при создании или обновлении campaign, с помощью заранее заготовленного промпта, по умолчанию тексты не модерируются, включить модерацию можно 2мя способами:
1. Установить переменную окружения `MODERATE_AD_TEXT` в `true`, в этом случае модерироваться будут все тексты, при любых условиях
2. При создании или обновлении рекламы передать параметр `moderate_ad_text: true`, так можно модерировать тексты опционально (если не указана `MODERATE_AD_TEXT: true`, в этом случае флаг `moderate_ad_text` будет игнорироваться и валидация будет происходить всегда)

Для продакшена рекомендуется 1 способ, а для тестирования второй.

`Gigachat` анализирует текст, и на основе его ответа могут быть возвращены разные ошибки, если валидация не пройдена то возвращается 400 и ошибка модерации в теле ответа (non fields errors), вот возможные ошибки:

- "**Violence and threats in the ad_text**" — если в тексте есть насилие или угрозы  
- "**Drugs and prohibited substances in the ad_text**" — если в тексте есть что-то связанное с наркотиками  
- "**Presence of obscene language in the ad_text**" — если в тексте содержится нецензурная лексика  
- "**Direct insults to specific groups or individuals in the ad_text**" — если в тексте есть расизм, нацизм, оскорбления конкретных лиц или групп  
- "**Absolutely unreadable ad_text**" — если текст представляет собой набор несвязных символов или слов, никак не связанных по смыслу

На основе этих ошибок фронтенд может выводить разные сообщения пользователю.

Я считаю то что использовать LLM в этой задаче хорошее решение, поскольку можно классифицировать нарушения, и LLM может распознать в тексте скрытые намеки, или завуалированный мат (например через латиницу и спец символы), что позволяет этому подходу быть более гибким и универсальным, чем обычные фильтры.

## Загрузка изображений
Для возможности загрузки изображений нужно установить переменную окружения `MULTI_PART_DATA_CAMPAIGN: true`, в этом случае при создании и обновлении кампаний нужно использовать формат `multipart/form-data`, изображения нужно поместить в виде файлов в необязательный параметр `uploaded_images`, после загрузки в ответе будет поле `images` это массив url по которым можно получить загруженные изображения (отдает Nginx), это поле так же будет в ответе при получении клиентом рекламы,
P.S: targeting при этом режиме надо передавать как json объект в строке: 
```
{
  "gender": "MALE",
  "age_from": 2147483647,
  "age_to": 2147483647,
  "location": "string"
}
```
Вот так загружаются файлы в PostMan:
![img.png](img.png)

## Тестирование
Всего 47 тестов, есть как UNIT так и E2E, все они лежат в директориях `tests/` внутри django приложений (clients, advertisers), запуск тестов такой же как и запуск сервера в режиме dev, только команда заменяется на:
```bash
   python manage.py test
 ```

## Сценарии использования
### Рекламодатель
- Рекламодатель регистрируется в фронтенде, после чего отправляет запрос на bulk создание
- Создание кампании, рекламодатель создает кампанию, прикрепляя к ней изображения, пишет описание (по которому происходит генерация) или текст
- Управление кампаниями, по необходимости рекламодатель редактирует кампании, удаляет их
- После старта рекламы, рекламодатель просматривает статистику по рекламам, чтобы знать возможный поток клиентов (в том числе и по дням), и то сколько он должен нашему стартапу
- Получение прибыли, рекламодатель фиксирует повышение продаж и получает прибыль, за счет нашей рекламы, и платит нам

### Клиент
- Клиент регистрируется в каком то сервисе в котором возможно встроить рекламу, например тг канале, сервис взаимодествует с движком и отправляет запрос на регистрацию 
- Клиент просматривает контент, переодически получая подобранную под него рекламу которую ему подбирает движок, при отображении рекламы используются ее текст, заголовок и изображения
- Клиент кликает на рекламу переходя по ней, мы фиксируем это, после чего рекламодатель может получить прибыль если клиенту понравится услуга или товар
- Клиент покупает товар или услугу по рекламе, рекламодатель получает прибыль, а клиент товар или услугу


## Описание БД
Вот полная диаграмма БД со всеми связями
![db_diagram.png](db_diagram.png)
Что описывает каждая модель:
- `Campaign` - Модель рекламы
- `CampaignImage`- Изображение для рекламы, храниться путь до загруженного изображения
- `Target` - Модель таргетинга для Campaign (One to One)
- `Advetiser`- Модель рекламодателя
- `Client` - Модель клиента 
- `AdImpression` - Модель просмотра рекламы, в ней записана стоимость на момент просмотра, день (created_at) и пара client_id и campaign_id, для одной пары client_id и campaign_id может существовать только одна AdImpression 
- `AdClick` - Модель клика по рекламе, в ней записана стоимость на момент клика, день (created_at) и пара client_id и campaign_id, для одной пары client_id и campaign_id может существовать только один AdClick
- `MLScore` - Модель оценки клиента ML, для одной пары client_id и advertiser_id может существовать только один MLScore
- `CurrentDate` - Текущий день в системе, по умолчанию 0, может существовать максимум в одном экземпляре

## Не реализованные функциональные требования
TG бота и визуализацию я не успел сделать, но структура проекта предполагала его наличия, для этого есть директория bot, в которую можно будет его просто добавить